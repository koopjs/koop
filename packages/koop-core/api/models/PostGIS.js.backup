var pg = require('pg');

module.exports = {
  infoTable: 'koopinfo', 
  timerTable: 'kooptimers', 

  connect: function( conn ){
    var self = this;
    console.log(conn);
    this.client = new pg.Client( conn );
    this.client.connect(function(err) {
      if ( err ){
        console.log('Cannot connect to the given database', conn);
        process.exit();
      } else {
        console.log('Connected to postgres db for storage', conn);
        // creates table only if they dont exist
        self._createTable(self.infoTable, "( id varchar(255) PRIMARY KEY, info varchar(500000))");
        self._createTable(self.timerTable, "( id varchar(255) PRIMARY KEY, expires timestamp)");
      }
    });
    return this; 
  },


  // get data out of the db
  select: function(key, options, callback){
    var self = this;
    //var layer = 0;
    var error = false,
      totalLayers,
      queryOpts = {}, 
      allLayers = [];

    // closure to check each layer and send back when done
    var collect = function(err, data){
      if (err) error = err;
      allLayers.push(data);
      if (allLayers.length == totalLayers){
        callback(error, allLayers);
      }
    };

    this.client.query('select info from '+this.infoTable+' where id="'+(key+":info")+'"', function(err, result){
      if ( err || !result ){
        callback('Not Found', []);
      } else {
        var info = JSON.parse(result[0].info);
        totalLayers = info.length;

        info.forEach(function(layer, i){
          /*if ( options.geometry ){
            if ( typeof(options.geometry) == 'string' ){
              options.geometry = JSON.parse( options.geometry );
            }
            var box = options.geometry;
            queryOpts = {"geometry":{ $geoWithin:{ $geometry:{"type":"Polygon","coordinates":[[
              [box.xmin, box.ymin],
              [box.xmax, box.ymin],
              [box.xmax, box.ymax],
              [box.xmin, box.ymax],
              [box.xmin, box.ymin]
            ]]}}}};
          }*/
          self.client.query( 'select * from ' + key+':'+i ).find( queryOpts ).toArray(function (err, result) {
            //console.log('select docs', JSON.stringify(queryOpts));
            if ( result && result.rows && result.rows.length ) {
              collect( null, {
                type: 'FeatureCollection', 
                features: result.rows, 
                name: layer.name, 
                sha: layer.sha, 
                updated_at: layer.updated_at 
              });
            } else {
              collect( 'Not Found', null );
            }
          });
        });
      }
    });
  },

  // create a collection and insert features
  // create a 2d index 
  insert: function( key, geojson, callback ){
    var self = this; 
    var info = [],
      count = 0;
      error = null;
    var check = function( err, success){
      if (err) error = err;
      count++;
      if (count == geojson.length){
        self.client.query( 'insert into '+self.infoTable+' values ('+key+':info,'+JSON.stringify(info)+')', function(){
          callback(error, true);
        });
      }
    };
    geojson.forEach(function( layer, i ){
      info[i] = { name: layer.name };
      info[i].updated_at = layer.updated_at;
      info[i].sha = layer.sha;
   
      var table = key+':'+i;
      console.log(self._buildSchemaFromFeature(layer.features[0]));
      var geomType = layer.features[0].geometry.type.toUpperCase();
      self._createTable( table, self._buildSchemaFromFeature(layer.features[0]), geomType, function(err, result){
        //console.log('created table', table, layer.features.length);
        layer.features.forEach(function(feature, i){
          self._insertFeature(table, feature, i);
        });
        check(err, true);
      });     
    });
    
  },

  _insertFeature: function(table, feature, i){
    var vals = '(';
    var list = [feature.id || i];
    for (var prop in feature.properties){
      list.push('"' + feature.properties[ prop ] + '"');
    }
    vals += list.join(',') + ')';
    var sql = 'insert into "'+table+'" VALUES '+ vals;
    console.log(sql); 
    this.client.query(sql);
  },


  remove: function( key, callback){
    var self = this;
    var totalLayers, processedLayers = 0;
    var collect = function(){
      processedLayers++;
      if ( processedLayers == totalLayers ){
        //delete row from info table 
        self.client.query("delete from "+this.infoTable+" where id='"+(key+':info')+"'", function(){
          callback();
        })
      }
    };
  
    this.client.query('select info from '+this.infoTable+' where id="'+(key+":info")+'"', function(err, result){
      if ( !result ){
        // nothing to remove
        callback( null, true );
      } else {
        var info = JSON.parse(result[0].info);
        totalLayers = info.length;
        info.forEach(function(layer, i){
          self.dropTable(key+':'+i, function(){
            collect();
          });
        });
      }
    });
  },

  dropTable: function(table, callback){
    this.client.query('drop table '+table , callback);
  },

  services: { 
    register: function( type, info, callback){
      Mongo._collection( type ).insert( info,  function(err, result){
        callback( err, true );
      });
    },

    count: function( type, callback){
      Mongo._collection( type ).count( function(err, cnt){
        callback( err, cnt );
      });
    },

    remove: function( type, id, callback){
      Mongo._collection( type ).remove( { _id: id },  function(err, result){
        callback( err, true );
      });
    },

    get: function( type, id, callback){
      Mongo._collection( type ).find( ( (id) ? { _id: id } : {})).toArray(function (err, docs) {
        if (!docs.length) err = 'No service found by that id';
        callback( err, docs );
      });
    }
  },

  timer: {
    set: function(key, expires, callback){
      Mongo._collection( 'timers' ).ensureIndex( { "expireAt": 1 }, { expireAfterSeconds: 3600 } )
      Mongo._collection( 'timers' ).insert({key: key, expiresAt: new Date() });
      callback( null, true);
    },
    get: function(key, callback){
      Mongo._collection( 'timers' ).findOne({key: key}, function(err, timer){
        callback(err, timer);
      });
    }
  },


  //--------------
  // PRIVATE METHODS
  //-------------

  _collection: function(key){
    return this.client.collection( key );
  },

  // checks to see in the info table exists, create it if not
  _createTable: function(name, schema, geometryType, callback){
    var self = this;
    var sql = "select exists(select * from information_schema.tables where table_name='"+ name +"')";
    this.client.query(sql, function(err, result){
      if ( !result.rows[0].exists ){
        var create = "CREATE TABLE \"" + name + "\" " + schema;
        self.client.query(create, function(err, result){
          //console.log('created table:', err, result, name);
          if ( geometryType ){
            self.client.query('SELECT AddGeometryColumn (\'public\', \''+name+'\', \'geom\', 4326, \''+geometryType+'\', 2, false)', function(err, result){
              console.log('add geom column', err);
              if (callback) {
                callback();
              }
            });
          } else if (callback) {
            callback();
          }
        });
      } else if (callback){
        callback();
      }
    });
  },

  _buildSchemaFromFeature: function(feature){
    var schema = '(';
    var props = ['id varchar(255) PRIMARY KEY'];
    for (var prop in feature.properties){
      // TODO look up the field type based on value
      props.push(prop + 'varchar(255)'); 
    }
    schema += props.join(',') + ')';
    return schema;
  }

};
